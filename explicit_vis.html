<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>World Map Visualization</title>
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
  <script src="https://cdn.anychart.com/releases/8.11.0/js/anychart-core.min.js"></script>
  <script src="https://cdn.anychart.com/releases/8.11.0/js/anychart-heatmap.min.js"></script>
  <style>
    /* Tooltip styles */
    .tooltip {
      position: absolute;
      top: 50px; /* Adjust as needed */
      left: 50%; /* Center horizontally */
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 5px;
      pointer-events: none; /* Ensure the tooltip does not block mouse events */
      transition: opacity 0.3s ease-in-out; /* Add a smooth transition */
      z-index: 999; /* Ensure it's above other elements */
    }

    .tooltipPerm {
      position: absolute;
      font-size: 30px;
      top: 50px; /* Adjust as needed */
      left: 70%; /* Center horizontally */
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 25px;
      padding-left: 50px;
      padding-right: 50px;
      border-radius: 5px;
      pointer-events: none; /* Ensure the tooltip does not block mouse events */
      transition: opacity 0.3s ease-in-out; /* Add a smooth transition */
      z-index: 999; /* Ensure it's above other elements */
    }

    #container {
      height: 150px; /* Adjust as needed */
      width: 100%; /* Occupy full width */
      padding-top: : 2%;
    }

    #info-container {
      position: absolute;
      top: 20%;
      right: 0;
      width: 50%; /* Adjust width as needed */
      height: 35%;
      padding: 20px;
      background-color: #ffffff;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      border-radius: 5px;
    }

    #info-container h2 {
      font-size: 26px;
      margin-bottom: 10px;
    }

    #info-container p {
      font-size: 20px;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    #info-container p::before {
      content: "â€¢"; /* Unicode for a bullet point */
      color: black; /* Change color as needed */
      margin-right: 5px; /* Adjust spacing between points */
    }

  </style>
</head>
<body>
  <!-- Add year and month tooltips -->
  <div class="tooltipPerm" id="yearMonthTooltip"></div>

  <!-- Add year and month sliders -->
  <div>
    <label for="yearSlider">Year:</label>
    <input type="range" min="2017" max="2020" value="2017" class="slider" id="yearSlider" disabled>
    <!-- <span id="yearValue"></span> -->
  </div>
  <div>
    <label for="monthSlider">Month:</label>
    <input type="range" min="1" max="12" value="1" class="slider" id="monthSlider" disabled>
    <!-- <span id="monthValue"></span> -->

  </div>

  <!-- Create an element where the map will take place -->
  <svg id="my_dataviz" width="800" height="600"></svg>
  <div id="info-container">
    <!-- Add your text and images here -->
    <h2>Welcome!</h2>
    <p>
      Hover over the choropleth's countries to see the corresponding heatmap of genres.<br></p>
    <p>
      Use left and right arrow keys to navigate between months and years.<br></p>
    <p>
      Click on a country to make the heatmap of that month, year of the country permanently visible.<br></p>
    <p>
      Double click while on that month and year on the country to make that permanent heatmap disappear.
    </p>
  </div>
  </div>
  <!-- Tooltip -->
  <div class="tooltip" style="opacity: 0;"></div>

  <div id="container"></div>

  <script>
    var isClicked = {};

    var monthList = [
    'Filler', 'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
    ];

    var years = ['2017', '2018', '2019', '2020']

    years.forEach(function (year) {
      monthList.forEach(function (month) {
        console.log("isClicked[", month+year , "] = {}]");
        isClicked[month + year] = {};
      });
    });

    console.log(isClicked);

    // The svg
    var svg = d3.select("svg"),
      width = +svg.attr("width"),
      height = +svg.attr("height");

    // Map and projection
    var path = d3.geoPath();
    var projection = d3.geoMercator()
      .scale(150)
      .center([0, 20])
      .translate([width / 2, height / 2]);

    // Color scale
    var gradientScale = d3.scaleLinear()
      .domain([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
      .range(["#b3d9ff", "#80b3ff", "#4d8cff", "#1a66ff", "#0047b3", "#ff9999", "#ff6666", "#ff3333", "#ff0000", "#cc0000", "#990000"]);

    // Load external data and boot
    d3.queue()
      .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
      .defer(d3.csv, "FinalDatabase_updated.csv?v=1") // Load CSV data with unique query parameter
      .await(ready);

    function ready(error, topo, data) {
      var yearSlider = document.getElementById("yearSlider");
      var monthSlider = document.getElementById("monthSlider");
      var prevMonthButton = document.getElementById("prevMonth");
      var nextMonthButton = document.getElementById("nextMonth");
      var yearOutput = document.getElementById("yearValue");
      var monthOutput = document.getElementById("monthValue");
      var tooltipPerm = document.getElementById("yearMonthTooltip");

      // Draw the initial map
      drawMap(topo, data, yearSlider.value, monthSlider.value);

      // Update year and month values
      updateYearMonth();

      yearSlider.oninput = function () {
        yearOutput.innerHTML = this.value;
        var selectedYear = this.value;
        if (selectedYear == "2020") {
          monthSlider.max = "10"; // Limit month slider range
          if (parseInt(monthSlider.value) > 10) {
            monthOutput.innerHTML = "10";
            monthSlider.value = "10";
          }
        } else {
          monthSlider.max = "12"; // Reset month slider range
        }
        redrawMap(topo, data, this.value, monthSlider.value); // Redraw map when year changes
        updateYearMonth();
      }

      monthSlider.oninput = function () {
        monthOutput.innerHTML = this.value;
        redrawMap(topo, data, yearSlider.value, this.value); // Redraw map when month changes
        updateYearMonth();
      }

      // Function to update the year and month tooltip
      function updateYearMonth() {
        var year = yearSlider.value;
        var month = monthSlider.value;
        tooltipPerm.innerHTML = "<strong>" + monthList[parseInt(month)] + "</strong> " + year; // Update tooltip content
      }

      document.addEventListener("keydown", function(event) {
        var key = event.key;
        if (key === "ArrowLeft") {
          if (parseInt(monthSlider.value) > 1) {
            monthSlider.value = parseInt(monthSlider.value) - 1;
          } else {
            if (parseInt(yearSlider.value) > 2017) {
              yearSlider.value = parseInt(yearSlider.value) - 1;
              monthSlider.value = 12;
            }
          }
          redrawMap(topo, data, yearSlider.value, monthSlider.value);
          updateYearMonth();
        } else if (key === "ArrowRight") {
          console.log(monthSlider.value, " ", monthSlider.max);
          console.log(yearSlider.value);
          if (parseInt(monthSlider.value) < parseInt(monthSlider.max)) {
            monthSlider.value = parseInt(monthSlider.value) + 1;
          } else {
            if (parseInt(yearSlider.value) < 2020) {
              yearSlider.value = parseInt(yearSlider.value) + 1;
              monthSlider.value = 1;
            }
          }
          redrawMap(topo, data, yearSlider.value, monthSlider.value);
          updateYearMonth();
        }
      });

      // prevMonthButton.onclick = function () {
      //   if (parseInt(monthSlider.value) > 1) {
      //     monthSlider.value = parseInt(monthSlider.value) - 1;
      //   } else {
      //     if (parseInt(yearSlider.value) > 2017) {
      //       yearSlider.value = parseInt(yearSlider.value) - 1;
      //       monthSlider.value = 12;
      //     }
      //   }
      //   redrawMap(topo, data, yearSlider.value, monthSlider.value);
      //   updateYearMonth();
      // }
      //
      // nextMonthButton.onclick = function () {
      //   if (parseInt(monthSlider.value) < parseInt(monthSlider.max)) {
      //     monthSlider.value = parseInt(monthSlider.value) + 1;
      //   } else {
      //     if (parseInt(yearSlider.value) < 2020) {
      //       yearSlider.value = parseInt(yearSlider.value) + 1;
      //       monthSlider.value = 1;
      //     }
      //   }
      //   redrawMap(topo, data, yearSlider.value, monthSlider.value);
      //   updateYearMonth();
      // }

      function drawMap(topo, data, year, month) {
        console.log(year + "-" + (month.length === 1 ? '0' + month : month));
        var filteredData = data.filter(function (d) {
          var modifiedMonthString = month.length === 1 ? '0' + month : month;
          return d.Release_date.includes(year + "-" + modifiedMonthString);
        });

        // Store all unique values of the 'Country' column in filteredData
        var uniqueCountries = [...new Set(filteredData.map(d => d.Country))];

        years.forEach(function (year) {
          monthList.forEach(function (month) {
            uniqueCountries.forEach(function (country) {
              isClicked[month + year][country] = 0;
            });
          });
        });

        // Calculate the explicit percentage and count for each country
        var countryExplicitData = {};
        uniqueCountries.forEach(function (country) {
          var countryTotalData = filteredData.filter(function (d) {
            return d.Country === country;
          });
          var explicitCount = countryTotalData.filter(function (d) {
            return d.Explicit === 'True';
          }).length;
          var totalCount = countryTotalData.length;
          var percentageExplicit = totalCount > 0 ? (explicitCount * 100 / totalCount) : 0;
          countryExplicitData[country] = {
            explicitCount: explicitCount,
            totalCount: totalCount,
            percentageExplicit: percentageExplicit
          };
        });

      // Draw the map
      svg.selectAll("path")
        .data(topo.features)
        .enter()
        .append("path")
        .attr("d", d3.geoPath().projection(projection))
        .attr("fill", function (d) {
          var countryName = d.properties.name;
          var data = countryExplicitData[countryName];
          if (!data || data.totalCount === 0) {
            return "grey"; // Set color to grey for countries with no explicit songs
          } else {
            var explicitPercentage = data.percentageExplicit;
            console.log(countryName + ": " + explicitPercentage + "% Explicit");
            return gradientScale(explicitPercentage); // Use the gradient scale for countries with explicit songs
          }
        })
        .attr("class", "Country")
        .style("stroke", "transparent")
        .on("mouseover", function (d) {
          var countryName = d.properties.name;
          var data = countryExplicitData[countryName];
          var explicitCount = data ? data.explicitCount : 0;
          var totalCount = data ? data.totalCount : 0;
          var explicitPercentage = data ? data.percentageExplicit : 0;

          var tooltip = d3.select(".tooltip");
          tooltip.transition()
            .duration(100)
            .style("opacity", .9);
          tooltip.html(
            "<strong>" + countryName + "</strong><br>" +
            "Explicit Percentage: " + explicitPercentage.toFixed(2) + "%<br>" +
            explicitCount + " out of " + totalCount + " songs explicit"
          )
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY - 28) + "px");

          d3.selectAll(".Country")
            .transition()
            .duration(100)
            .style("opacity", .5)
          d3.select(this)
            .transition()
            .duration(100)
            .style("opacity", 1)
            .style("stroke", "black")

          anychart.onDocumentReady(function () {
              var countryName = d.properties.name;
              var container = document.getElementById('container');
              // container.innerText = "Selected Country: " + countryName;
              console.log(d.properties.name)

              var genres = [
                'dance pop',
                'latin',
                'pop',
                'k-pop',
                'n-a',
                'german hip hop',
                'atl hip hop',
                'francoton',
                'dutch hip hop',
                'big room',
                'hip hop',
                'canadian hip hop',
                'emo rap',
                'french hip hop',
                'finnish dance pop',
                'melodic rap',
                'boy band',
                'italian hip hop',
                'alternative metal',
                'canadian pop',
                'modern rock',
                'chicago rap',
                'deep german hip hop',
                'colombian pop',
                'conscious hip hop',
                'adult standards',
                'detroit hip hop',
                'alternative r&b',
                'electropop',
                'canadian contemporary r&b',
                'edm',
                'art pop',
                'polish hip hop',
                'dfw rap',
                'mandopop',
                'danish hip hop',
                'rap'
              ]

              var heatmapData = [];
              var country = d.properties.name;
              var countryData = {};
              countryData['name'] = country;
              genres.forEach(function(genre) {
                var genreSongs = filteredData.filter(function(d) {
                  return d.Country === country && d.Genre === genre
                }).length;

                var totalSongs = filteredData.filter(function(d) {
                  return d.Country === country;
                }).length;

                var percentage = totalSongs > 0 ? (genreSongs / totalSongs) * 100 : 0;
                countryData[genre] = percentage;
                countryData[genre + 'filtered'] = genreSongs;
                countryData[genre + 'total'] = totalSongs;
              });
              heatmapData.push(countryData);

              var anychartData = [];
              heatmapData.forEach(function(countryData) {
                genres.forEach(function(genre) {
                  var newdic = {};
                  newdic['x'] = genre;
                  newdic['y'] = countryData["name"];
                  newdic['heat'] = countryData[genre];
                  newdic['filtered'] = countryData[genre + 'filtered'];
                  newdic['total'] = countryData[genre + 'total'];
                  anychartData.push(newdic);
                });
              });

              console.log(anychartData);

              container.innerHTML = '';

              // Create AnyChart heatmap
              var chart = anychart.heatMap(anychartData);
              chart.title("Heatmap of Genre Distribution by Country");
              chart.container(container);

              // Define the color scale for the heatmap
              var colorScale = anychart.scales.linearColor();
              colorScale.colors(["black", "#010101", "#020202", "#030303", "#040404", "#050505", "#060606", "#070707", "#080808", "#090909", "#0A0A0A", "#0B0B0B", "#0C0C0C", "#0D0D0D", "#0E0E0E", "#0F0F0F", "#101010", "#111111",
              "#121212", "#131313", "#141414", "#151515", "#161616", "#171717", "#181818", "#191919", "#1A1A1A", "#1B1B1B", "#1C1C1C", "#1D1D1D", "#1E1E1E", "#1F1F1F", "#202020", "#212121", "#222222", "#232323", "#242424",
              "#252525", "#262626", "#272727", "#282828", "#292929", "#2A2A2A", "#2B2B2B", "#2C2C2C", "#2D2D2D", "#2E2E2E", "#2F2F2F", "#303030", "#313131", "#323232", "#333333", "#343434", "#353535", "#363636", "#373737",
              "#383838", "#393939", "#3A3A3A", "#3B3B3B", "#3C3C3C", "#3D3D3D", "#3E3E3E", "#3F3F3F", "#404040", "#414141", "#424242", "#434343", "#444444", "#454545", "#464646", "#474747", "#484848", "#494949", "#4A4A4A",
              "#4B4B4B", "#4C4C4C", "#4D4D4D", "#4E4E4E", "#4F4F4F", "#505050", "#515151", "#525252", "#535353", "#545454", "#555555", "#565656", "#575757", "#585858", "#595959", "#5A5A5A", "#5B5B5B", "#5C5C5C", "#5D5D5D",
              "#5E5E5E", "#5F5F5F", "#606060", "#616161", "#626262", "#636363", "#646464", "#656565", "#666666", "#676767", "#686868", "#696969", "#6A6A6A", "#6B6B6B", "#6C6C6C", "#6D6D6D", "#6E6E6E", "#6F6F6F", "#707070",
              "#717171", "#727272", "#737373", "#747474", "#757575", "#767676", "#777777", "#787878", "#797979", "#7A7A7A", "#7B7B7B", "#7C7C7C", "#7D7D7D", "#7E7E7E", "#7F7F7F", "#808080", "#818181", "#828282", "#838383",
              "#848484", "#858585", "#868686", "#878787", "#888888", "#898989", "#8A8A8A", "#8B8B8B", "#8C8C8C", "#8D8D8D", "#8E8E8E", "#8F8F8F", "#909090", "#919191", "#929292", "#939393", "#949494", "#959595", "#969696",
              "#979797", "#989898", "#999999", "#9A9A9A", "#9B9B9B", "#9C9C9C", "#9D9D9D", "#9E9E9E", "#9F9F9F", "#A0A0A0", "#A1A1A1", "#A2A2A2", "#A3A3A3", "#A4A4A4", "#A5A5A5", "#A6A6A6", "#A7A7A7", "#A8A8A8", "#A9A9A9",
              "#AAAAAA", "#ABABAB", "#ACACAC", "#ADADAD", "#AEAEAE", "#AFAFAF", "#B0B0B0", "#B1B1B1", "#B2B2B2", "#B3B3B3", "#B4B4B4", "#B5B5B5", "#B6B6B6", "#B7B7B7", "#B8B8B8", "#B9B9B9", "#BABABA", "#BBBBBB", "#BCBCBC",
              "#BDBDBD", "#BEBEBE", "#BFBFBF", "#C0C0C0", "#C1C1C1", "#C2C2C2", "#C3C3C3", "#C4C4C4", "#C5C5C5", "#C6C6C6", "#C7C7C7", "#C8C8C8", "#C9C9C9", "#CACACA", "#CBCBCB", "#CCCCCC", "#CDCDCD", "#CECECE", "#CFCFCF",
              "#D0D0D0", "#D1D1D1", "#D2D2D2", "#D3D3D3", "#D4D4D4", "#D5D5D5", "#D6D6D6", "#D7D7D7", "#D8D8D8", "#D9D9D9", "#DADADA", "#DBDBDB", "#DCDCDC", "#DDDDDD", "#DEDEDE", "#DFDFDF", "#E0E0E0", "#E1E1E1", "#E2E2E2",
              "#E3E3E3", "#E4E4E4", "#E5E5E5", "#E6E6E6", "#E7E7E7", "#E8E8E8", "#E9E9E9", "#EAEAEA", "#EBEBEB", "#ECECEC", "#EDEDED", "#EEEEEE", "#EFEFEF", "#F0F0F0", "#F1F1F1", "#F2F2F2", "#F3F3F3", "#F4F4F4", "#F5F5F5",
              "#F6F6F6", "#F7F7F7", "#F8F8F8", "#F9F9F9", "#FAFAFA", "#FBFBFB", "#FCFCFC", "#FDFDFD", "#FEFEFE", "yellow"]); // Black for 0% participation, yellow for others

              chart.tooltip().titleFormat(function () {
                return 'Value: ' + this.getData('heat').toFixed(2) + '%' + ' (' + this.getData('filtered') + '/' + this.getData('total') + ' are Explicit' + ')';
              });
              chart.tooltip().format(function () {
                return 'Country: ' + this.getData('y') + ', Genre: ' + this.getData('x');
              });

              // Set x-axis labels (genres) and y-axis labels (countries)
              chart.xAxis().staggerMode(true).staggerLines(2); // Stagger mode to fit more labels
              chart.xAxis().labels().format(function() {
                // Split the genre label into words
                var words = genres[this.index].split(' ');
                if (words.length > 1){
                  // Extract the first letter of each word and join them with periods
                  var abbreviatedLabel = words[0].charAt(0) + '. ';
                  abbreviatedLabel += words.slice(1).join(' ');
                  return abbreviatedLabel;
                }
                else{
                  return genres[this.index];
                }
              }).fontWeight('bold').fontColor('black'); // Set font weight to bold and font color to black

              chart.yAxis().labels().format(function() {
                return country;
              }).fontWeight('bold').fontColor('black'); // Set font weight to bold and font color to black

              chart.draw();
          });

        })
        .on("mouseout", function (d) {
          d3.select(".tooltip").transition()
            .duration(100)
            .style("opacity", 0);

          d3.selectAll(".Country")
            .transition()
            .duration(0)
            .style("opacity", .8)
          d3.select(this)
            .transition()
            .duration(0)
            .style("stroke", "transparent")

          container.innerHTML = '';

        })
        .on("click", function (d) {
            var container = document.getElementById(d.properties.name.toLowerCase().replace(/\s+/g, '-') + monthList[monthSlider.value] + yearSlider.value.toString() + '-container');
            // Check if the container already exists
            console.log(monthList[monthSlider.value] + yearSlider.value.toString())
            console.log(isClicked[monthList[monthSlider.value] + yearSlider.value.toString()])
            if (isClicked[monthList[monthSlider.value] + yearSlider.value.toString()][d.properties.name]) {
                // If the container doesn't exist, create it
                if (container){
                  container.innerHTML = '';
                  isClicked[monthList[monthSlider.value] + yearSlider.value.toString()][d.properties.name] = 0;
                }
            }
            else{
            // Display the clicked country's name inside the container div
              anychart.onDocumentReady(function () {
                var countryName = d.properties.name;
                console.log(d.properties.name)

                var genres = [
                  'dance pop',
                  'latin',
                  'pop',
                  'k-pop',
                  'n-a',
                  'german hip hop',
                  'atl hip hop',
                  'francoton',
                  'dutch hip hop',
                  'big room',
                  'hip hop',
                  'canadian hip hop',
                  'emo rap',
                  'french hip hop',
                  'finnish dance pop',
                  'melodic rap',
                  'boy band',
                  'italian hip hop',
                  'alternative metal',
                  'canadian pop',
                  'modern rock',
                  'chicago rap',
                  'deep german hip hop',
                  'colombian pop',
                  'conscious hip hop',
                  'adult standards',
                  'detroit hip hop',
                  'alternative r&b',
                  'electropop',
                  'canadian contemporary r&b',
                  'edm',
                  'art pop',
                  'polish hip hop',
                  'dfw rap',
                  'mandopop',
                  'danish hip hop',
                  'rap'
                ]

                var heatmapData = [];
                var country = d.properties.name;
                var countryData = {};
                countryData['name'] = country;

                if (isClicked[monthList[monthSlider.value] + yearSlider.value.toString()][country]){
                  isClicked[monthList[monthSlider.value] + yearSlider.value.toString()][country] = 0;
                }
                else{
                  isClicked[monthList[monthSlider.value] + yearSlider.value.toString()][country] = 1;
                }

                var countrysname = d.properties.name;
                var containerId = countrysname.toLowerCase().replace(/\s+/g, '-') + monthList[monthSlider.value] + yearSlider.value.toString() + '-container'; // Convert country name to lowercase and replace spaces with dashes for ID
                var container = document.getElementById(containerId);

                // Check if the container already exists
                if (!container) {
                    // If the container doesn't exist, create it
                    container = document.createElement('div');
                    container.id = containerId;
                    document.body.appendChild(container); // Append the container to the body or another parent element
                }

                console.log("isClicked[" + monthList[monthSlider.value] + yearSlider.value.toString() + "]" + "[" + countryName + "] = ", isClicked[monthList[monthSlider.value] + yearSlider.value.toString()][countryName]);

                genres.forEach(function(genre) {
                  var genreSongs = filteredData.filter(function(d) {
                    return d.Country === country && d.Genre === genre
                  }).length;

                  var totalSongs = filteredData.filter(function(d) {
                    return d.Country === country;
                  }).length;

                  var percentage = totalSongs > 0 ? (genreSongs / totalSongs) * 100 : 0;
                  countryData[genre] = percentage;
                  countryData[genre + 'filtered'] = genreSongs;
                  countryData[genre + 'total'] = totalSongs;
                });
                heatmapData.push(countryData);

                var anychartData = [];
                heatmapData.forEach(function(countryData) {
                  genres.forEach(function(genre) {
                    var newdic = {};
                    newdic['x'] = genre;
                    newdic['y'] = countryData["name"];
                    newdic['heat'] = countryData[genre];
                    newdic['filtered'] = countryData[genre + 'filtered'];
                    newdic['total'] = countryData[genre + 'total'];
                    anychartData.push(newdic);
                  });
                });

                console.log(anychartData);

                container.innerHTML = '';

                // Create AnyChart heatmap
                var chart = anychart.heatMap(anychartData);
                chart.title("Heatmap of Genre Distribution of " + monthList[monthSlider.value] + " " + yearSlider.value);
                chart.container(container);

                // Define the color scale for the heatmap
                var colorScale = anychart.scales.linearColor();
                colorScale.colors(["black", "#010101", "#020202", "#030303", "#040404", "#050505", "#060606", "#070707", "#080808", "#090909", "#0A0A0A", "#0B0B0B", "#0C0C0C", "#0D0D0D", "#0E0E0E", "#0F0F0F", "#101010", "#111111",
                "#121212", "#131313", "#141414", "#151515", "#161616", "#171717", "#181818", "#191919", "#1A1A1A", "#1B1B1B", "#1C1C1C", "#1D1D1D", "#1E1E1E", "#1F1F1F", "#202020", "#212121", "#222222", "#232323", "#242424",
                "#252525", "#262626", "#272727", "#282828", "#292929", "#2A2A2A", "#2B2B2B", "#2C2C2C", "#2D2D2D", "#2E2E2E", "#2F2F2F", "#303030", "#313131", "#323232", "#333333", "#343434", "#353535", "#363636", "#373737",
                "#383838", "#393939", "#3A3A3A", "#3B3B3B", "#3C3C3C", "#3D3D3D", "#3E3E3E", "#3F3F3F", "#404040", "#414141", "#424242", "#434343", "#444444", "#454545", "#464646", "#474747", "#484848", "#494949", "#4A4A4A",
                "#4B4B4B", "#4C4C4C", "#4D4D4D", "#4E4E4E", "#4F4F4F", "#505050", "#515151", "#525252", "#535353", "#545454", "#555555", "#565656", "#575757", "#585858", "#595959", "#5A5A5A", "#5B5B5B", "#5C5C5C", "#5D5D5D",
                "#5E5E5E", "#5F5F5F", "#606060", "#616161", "#626262", "#636363", "#646464", "#656565", "#666666", "#676767", "#686868", "#696969", "#6A6A6A", "#6B6B6B", "#6C6C6C", "#6D6D6D", "#6E6E6E", "#6F6F6F", "#707070",
                "#717171", "#727272", "#737373", "#747474", "#757575", "#767676", "#777777", "#787878", "#797979", "#7A7A7A", "#7B7B7B", "#7C7C7C", "#7D7D7D", "#7E7E7E", "#7F7F7F", "#808080", "#818181", "#828282", "#838383",
                "#848484", "#858585", "#868686", "#878787", "#888888", "#898989", "#8A8A8A", "#8B8B8B", "#8C8C8C", "#8D8D8D", "#8E8E8E", "#8F8F8F", "#909090", "#919191", "#929292", "#939393", "#949494", "#959595", "#969696",
                "#979797", "#989898", "#999999", "#9A9A9A", "#9B9B9B", "#9C9C9C", "#9D9D9D", "#9E9E9E", "#9F9F9F", "#A0A0A0", "#A1A1A1", "#A2A2A2", "#A3A3A3", "#A4A4A4", "#A5A5A5", "#A6A6A6", "#A7A7A7", "#A8A8A8", "#A9A9A9",
                "#AAAAAA", "#ABABAB", "#ACACAC", "#ADADAD", "#AEAEAE", "#AFAFAF", "#B0B0B0", "#B1B1B1", "#B2B2B2", "#B3B3B3", "#B4B4B4", "#B5B5B5", "#B6B6B6", "#B7B7B7", "#B8B8B8", "#B9B9B9", "#BABABA", "#BBBBBB", "#BCBCBC",
                "#BDBDBD", "#BEBEBE", "#BFBFBF", "#C0C0C0", "#C1C1C1", "#C2C2C2", "#C3C3C3", "#C4C4C4", "#C5C5C5", "#C6C6C6", "#C7C7C7", "#C8C8C8", "#C9C9C9", "#CACACA", "#CBCBCB", "#CCCCCC", "#CDCDCD", "#CECECE", "#CFCFCF",
                "#D0D0D0", "#D1D1D1", "#D2D2D2", "#D3D3D3", "#D4D4D4", "#D5D5D5", "#D6D6D6", "#D7D7D7", "#D8D8D8", "#D9D9D9", "#DADADA", "#DBDBDB", "#DCDCDC", "#DDDDDD", "#DEDEDE", "#DFDFDF", "#E0E0E0", "#E1E1E1", "#E2E2E2",
                "#E3E3E3", "#E4E4E4", "#E5E5E5", "#E6E6E6", "#E7E7E7", "#E8E8E8", "#E9E9E9", "#EAEAEA", "#EBEBEB", "#ECECEC", "#EDEDED", "#EEEEEE", "#EFEFEF", "#F0F0F0", "#F1F1F1", "#F2F2F2", "#F3F3F3", "#F4F4F4", "#F5F5F5",
                "#F6F6F6", "#F7F7F7", "#F8F8F8", "#F9F9F9", "#FAFAFA", "#FBFBFB", "#FCFCFC", "#FDFDFD", "#FEFEFE", "yellow"]); // Black for 0% participation, yellow for others

                chart.tooltip().titleFormat(function () {
                  return 'Value: ' + this.getData('heat').toFixed(2) + '%' + ' (' + this.getData('filtered') + '/' + this.getData('total') + ' are Explicit' + ')';
                });
                chart.tooltip().format(function () {
                  return 'Country: ' + this.getData('y') + ', Genre: ' + this.getData('x');
                });

                chart.xAxis().staggerMode(true).staggerLines(2); // Stagger mode to fit more labels
                chart.xAxis().labels().format(function() {

                  var words = genres[this.index].split(' ');
                  if (words.length > 1){

                    var abbreviatedLabel = words[0].charAt(0) + '. ';
                    abbreviatedLabel += words.slice(1).join(' ');
                    return abbreviatedLabel;
                  }
                  else{
                    return genres[this.index];
                  }
                }).fontWeight('bold').fontColor('black');

                chart.yAxis().labels().format(function() {
                  return country;
                }).fontWeight('bold').fontColor('black');

                chart.draw();
            });
          }
        });
    }

    function redrawMap(topo, data, year, month) {
      svg.selectAll("path").remove();
      drawMap(topo, data, year, month);
    }
  }
</script>
